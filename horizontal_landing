//WARNING COMPATIBILITY CHECK
//-This script is only ment to work on non-atmosphere bodies, have not tested or run this on atmosphere bodies.
//-Only works if the ship does not have to stage in the middle of the landing burn. Otherwise all calculations might be thrown off
//-Only works if the ship is at near 0 starting inclination and very circular

// Landing position
CLEARVECDRAWS().
SAS OFF.
lock steering to srfretrograde.
set landing_pos to LATLNG(0,90).
set buffer_dist to 10.
set buffer_speed_h to 0.
set landing_per_buffer to 500.
set landing_eta_buffer to 50.
set CutOffThrottle to .75.
set MaxCount to 3.

lock R to ship:body:position.
lock angle_diff_h to VANG(-R, landing_pos:position - R).
lock dist_diff_h to (angle_diff_h/360)*2*(constant:pi)*R:mag.
lock Velocity_h_norm to VCRS(VCRS(R,ship:velocity:orbit),R):normalized.
lock Speed_h to VDOT(Velocity_h_norm,ship:velocity:orbit).
lock speed_diff_h to Speed_h-landing_pos:altitudevelocity(altitude):orbit:mag.
clearscreen.

set prev_dist_h to dist_diff_h.
wait .1.
set curr_dist_h to dist_diff_h.
set delta_dist_h to curr_dist_h - prev_dist_h. 

if delta_dist_h > 0 {
	set eta_node to ((constant:pi)*R:mag-dist_diff_h)/speed_diff_h.
	if eta_node < 60 {
		set eta_node to ((constant:pi)*R:mag-dist_diff_h+(constant:pi)*R:mag)/speed_diff_h.
		}
} else {
	set eta_node to ((constant:pi)*R:mag+dist_diff_h)/speed_diff_h.
	}
set R_per_landing to ship:body:radius + landing_pos:terrainheight + landing_per_buffer.
set SMA_landing to (R:mag + R_per_landing)/2.
set ecc_landing to (R:mag - R_per_landing)/(R:mag + R_per_landing).
set V_apo to sqrt(((1-ecc_landing)*ship:body:MU)/((1+ecc_landing)*SMA_landing)).
set deltaV_landing to V_apo - velocityat(ship,time:seconds + eta_node):orbit:mag.
for node in allnodes {remove node.}
set landing_node to NODE(TIME:seconds + eta_node, 0, 0, deltaV_landing).
ADD landing_node.

run executenode.

lock steering to srfretrograde.
set landing_pos to LATLNG(0,90).
set buffer_dist to 0.
set buffer_speed_h to 0.
set landing_per_buffer to 500.
set CutOffThrottle to 0.
set MaxCount to 3.

lock R to ship:body:position.
lock angle_diff_h to VANG(-R, landing_pos:position - R).
lock dist_diff_h to (angle_diff_h/360)*2*(constant:pi)*R:mag.
lock Velocity_h_norm to VCRS(VCRS(R,ship:velocity:orbit),R):normalized.
lock Speed_h to VDOT(Velocity_h_norm,ship:velocity:orbit).
lock speed_diff_h to Speed_h-landing_pos:altitudevelocity(altitude):orbit:mag.
clearscreen.

lock MaxThrustAccHor to -1*VDOT(Velocity_h_norm,availablethrust/mass*srfretrograde:vector).
lock Vmax_h to sqrt(MAX(0,2*(dist_diff_h-buffer_dist)*MaxThrustAccHor) + buffer_speed_h^2).

lock error_h to Vmax_h - speed_diff_h.
set errorP_h to 0.
set Kp_h to 0.06.
set errorD_h to 0.
set Kd_h to 0.04.
set ThrustSet to 0.
lock throttle to ThrustSet.
set time0 to time:seconds.
lock time1 to time:seconds - time0.
set count to 1.
set flightmode to 1.

set align_vector to landing_pos:altitudevelocity(altitude):orbit.
lock steering to align_vector.
print "Aligning with Surface Retrograde Preemptively".
until VANG(ship:facing:vector,align_vector) < 1 {
	print "Direction Angle Error = " + round(VANG(ship:facing:vector,align_vector),1) + "   "at(0,1).
}
clearscreen.
print "Warping to " + round(landing_eta_buffer,0) + "sec before Periapsis".
warpto(time:seconds + eta:periapsis - landing_eta_buffer).
lock steering to srfretrograde.
clearscreen.
until flightmode = 2 {
	set LandingVector to VECDRAW(landing_pos:position,(altitude-landing_pos:terrainheight+25)*(landing_pos:position-R):normalized,GREEN,"Landing Position",1.0,TRUE,.5).
	if flightmode = 1 {
	
		set error1_h to error_h.
		set t1 to time1.
		wait .00001.
		set error2_h to error_h.
		set t2 to time1.
		set dt to t2-t1.
		// I like to take an average error so its not going crazy due to discrete calculations.
		set errorP_h to .5*(error1_h+error2_h).
		set errorD_h_test to (error2_h-error1_h)/dt.
		//This next part is used as a running average, the Derivative term was behaving eratically thus this damps out the spikes.
		if count < MaxCount {
			if count < 2 {
				set errorD_h to errorD_h_test.
				}
			if count >= 2 {
				set errorD_h to (errorD_h*(count-1)+errorD_h_test)/count.
				}
			set count to count + 1.		
			}
		if count >= MaxCount {
		
			set errorD_h to (errorD_h*(MaxCount-1)+errorD_h_test)/MaxCount.
			}
		
		set ThrustSet to 1 - Kp_h*errorP_h - Kd_h*errorD_h.
		
		if ThrustSet > 1 {
			set ThrustSet to 1.
			}
		if ThrustSet < CutOffThrottle {
			set ThrustSet to 0.
			}
		if errorP_h < 0 {
			set ThrustSet to 1. // This is very important. If the error ever drops below 0, it means it might crash since the
								// equation is calculated based on full thrust. 
			}
		if speed_diff_h < 1 {
			set ThrustSet to 0.
			set flightmode to 2.
			}
		if (dist_diff_h < (buffer_dist + 5)) AND speed_diff_h < 2.5 {
			set ThrustSet to 0.
			set flightmode to 2.
			}
	}
	
	print "Horizontal Distance to Landing Site = " + round(dist_diff_h,2) + "     "at (0,0).
	print "Speed relative to Landing Site = " + round(speed_diff_h,2) at (0,1).
	print "MaxThrustAccHor = " + round(MaxThrustAccHor,2) at (0,2).
	print "Vmax_h = " + round(Vmax_h,2) at (0,3).
	print "errorP_h = " + round(errorP_h,2) at (0,4).
	print "errorD_h = " + round(errorD_h,2) at (0,5).
	print "ThrustSet = " + round(ThrustSet*100,2) + "%     " at (0,6).
	print "Flightmode = " + flightmode at (0,7).
	}
	run vertical_landing(landing_pos).