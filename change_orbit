set LAN_ship to ship:orbit:LAN.
set INC_ship to ship:orbit:inclination.
set AOP_ship to ship:orbit:argumentofperiapsis.
set PER_ship to ship:orbit:periapsis.
set APO_ship to ship:orbit:apoapsis.

parameter DesiredOrbit is lexicon("LAN",LAN_ship,"INC",INC_ship,"AOP",AOP_ship,"PER",PER_ship,"APO",APO_ship).

function Change_LAN_Inc {
	
	print "Line 1".
	parameter DesiredOrbit.
	local body_pos to ship:body:position.
	local INC_ship to ship:orbit:inclination.
	local R to -body_pos.
	local SMA_ship to ship:orbit:semimajoraxis.
	local LAN_des to DesiredOrbit["LAN"].
	local LAN_VEC to  solarprimevector*(SMA_ship)*R(0,-LAN_des,0).
	local Inc_Rotate to ANGLEAXIS(-1*DesiredOrbit["INC"],LAN_VEC).
	local Inc_Normal to Inc_Rotate*(V(0,-1,0):direction).
	local Inc_Normal to SMA_ship*Inc_Normal:vector.
	
	local AngVel_ship to SMA_ship*VCRS(R,ship:velocity:orbit):normalized.
	
	local LAN_relative_vec to SMA_ship*VCRS(AngVel_ship,Inc_Normal):normalized.
	
	local LAN_relative_theta to FindTheta_Vec(LAN_relative_vec).
	local LAN_eta to ETA_to_theta(LAN_relative_theta).
	local LAN_node to NODE( time:seconds + LAN_eta,0,0,0).
	add LAN_node.
	
	local delta_inc to VANG(AngVel_ship,Inc_Normal).
	local Vel_at_LAN to velocityat(ship,time:seconds + LAN_eta):orbit.
	local temp_dir to Vel_at_LAN:direction.
	local rotate_dir to ANGLEAXIS(delta_inc,LAN_relative_vec).
	local vel_rotated to rotate_dir*temp_dir.
	local New_Vel_at_LAN to (Vel_at_LAN:mag)*vel_rotated:vector:normalized.
	local burn_vector to New_Vel_at_LAN - Vel_at_LAN.
	local delta_v to burn_vector:mag.
	
	local max_acc to availablethrust/mass.
	local burn_time to delta_v/max_acc.
	
	lock steering to LOOKDIRUP(burn_vector,ship:facing:upvector).
	clearscreen.
	
	set facing_ang_diff to VANG(burn_vector,ship:facing:forevector).
	print "Aligning to Burn Vector".
	until facing_ang_diff < 1 {
		set facing_ang_diff to VANG(burn_vector,ship:facing:forevector).
		print "Direction Alignment Error = " + round(facing_ang_diff,1) + "    " at(0,1).
	}
	clearscreen.
	print "Alignment Complete".
	print "Warping to Burn Point".
	wait 2.
	warpto(time:seconds + LAN_node:eta - burn_time/2 - 20).
	
	wait until warp <= 0.
	clearscreen.
	//until delta_v < 0.1 {
	until false {
		set burn_vector to New_Vel_at_LAN - ship:velocity:orbit.
		set delta_v to burn_vector:mag.
		//set LAN_eta_burn to ETA_to_theta(LAN_relative_theta).
		if LAN_node:eta > burn_time/2 {
			print "ETA to Burn = " + round(LAN_node:eta - burn_time/2,2) + "    " at(0,1).
			print "DeltaV      = " + round(delta_v,2) + "    " at(0,2).
			print "Ship's LAN  = " + round(ship:orbit:LAN,2) + "    " at(0,3).
			print "Desired LAN = " + round(DesiredOrbit["LAN"],2) + "    " at(0,4).
			print "Ship's INC  = " + round(ship:orbit:inclination,2) + "    " at(0,5).
			print "Desired INC = " + round(DesiredOrbit["INC"],2) + "    " at(0,6).
		} else {
			clearscreen.
			local INC_diff to abs(DesiredOrbit["INC"] - ship:orbit:inclination).
			local LAN_diff to abs(DesiredOrbit["LAN"] - ship:orbit:LAN).
			print "Initiate Burn                          " at(0,1).
			print "DeltaV      = " + round(delta_v,2) + "    " at(0,2).
			print "Ship's LAN  = " + round(ship:orbit:LAN,2) + "    " at(0,3).
			print "Desired LAN = " + round(DesiredOrbit["LAN"],2) + "    " at(0,4).
			print "Diff LAN    = " + round(LAN_diff,2) + "    " at(0,5).
			print "Ship's INC  = " + round(ship:orbit:inclination,2) + "    " at(0,6).
			print "Desired INC = " + round(DesiredOrbit["INC"],2) + "    " at(0,7).
			print "Diff INC    = " + round(INC_diff,2) + "    " at(0,7).
			set max_acc to availablethrust/mass.
			lock throttle to delta_v/max_acc.
			
			local delta_inc1 to delta_inc.
			local delta_v1 to delta_v.
			//if delta_inc < 0.01 {
			if INC_diff < 0.01 AND LAN_diff < 0.01 {
				lock throttle to 0.
				clearscreen.
				print "Burn Complete".
				break.
			}
				
			if delta_v < 0.1 {
				lock throttle to 0.
				clearscreen.
				print "Burn Complete".
				break.
			}
			wait 0.
			local delta_v2 to delta_v.
			if delta_v2 > delta_v1 {
				lock throttle to 0.
				clearscreen.
				print "Burn Aborted, DeltaV Increasing".
				break.
			}
		}
	}
	
	// Vecdraws
	set LAN_VEC_Draw to vecdraw().
	set LAN_VEC_Draw:startupdater to { return ship:body:position. }.
	set LAN_VEC_Draw:vecupdater to { return LAN_VEC. }.
	set LAN_VEC_Draw:show to true.
	set LAN_VEC_Draw:color to RGB(255,0,0).
	
	set INC_VEC_Draw to vecdraw().
	set INC_VEC_Draw:startupdater to { return ship:body:position. }.
	set INC_VEC_Draw:vecupdater to { return Inc_Normal. }.
	set INC_VEC_Draw:show to true.
	set INC_VEC_Draw:color to RGB(0,255,0).
	
	set ANG_VEC_Draw to vecdraw().
	set ANG_VEC_Draw:startupdater to { return ship:body:position. }.
	set ANG_VEC_Draw:vecupdater to { return AngVel_ship. }.
	set ANG_VEC_Draw:show to true.
	set ANG_VEC_Draw:color to RGB(0,0,255).
	
	set Rel_LAN_VEC_Draw to vecdraw().
	set Rel_LAN_VEC_Draw:startupdater to { return ship:body:position. }.
	set Rel_LAN_VEC_Draw:vecupdater to { return LAN_relative_vec. }.
	set Rel_LAN_VEC_Draw:show to true.
	set Rel_LAN_VEC_Draw:color to RGB(255,255,0).
	
	set LAN_VEL_VEC_Draw to vecdraw().
	set LAN_VEL_VEC_Draw:startupdater to { return V(0,0,0). }.
	set LAN_VEL_VEC_Draw:vecupdater to { return Vel_at_LAN/50. }.
	set LAN_VEL_VEC_Draw:show to true.
	set LAN_VEL_VEC_Draw:color to RGB(255,0,0).
	
	set LAN_VEL_VEC_Draw2 to vecdraw().
	set LAN_VEL_VEC_Draw2:startupdater to { return V(0,0,0). }.
	set LAN_VEL_VEC_Draw2:vecupdater to { return New_Vel_at_LAN/50. }.
	set LAN_VEL_VEC_Draw2:show to true.
	set LAN_VEL_VEC_Draw2:color to RGB(0,255,0).
	
	set LAN_VEL_VEC_Draw3 to vecdraw().
	set LAN_VEL_VEC_Draw3:startupdater to { return Vel_at_LAN/50. }.
	set LAN_VEL_VEC_Draw3:vecupdater to { return burn_vector/50. }.
	set LAN_VEL_VEC_Draw3:show to true.
	set LAN_VEL_VEC_Draw3:color to RGB(0,255,0).
	
	wait 1.
	
	return true.
}

function FindTheta_Vec {

	parameter test_vector is -ship:body:position.
	
	local body_pos to ship:body:position.
	local R to -body_pos.
	local AngVel_ship to VCRS(R,ship:velocity:orbit):normalized.
	local theta_test to VANG(test_vector,R).
	local cross_test to VCRS(R,test_vector):normalized.
	
	local check_vec to cross_test + AngVel_ship.
	local theta_ship is ship:orbit:trueanomaly.
	local theta is theta_ship.
	
	if check_vec:mag > 1 {
		set theta to theta_ship + theta_test.
	} else {
		set theta to theta_ship - theta_test.
	}
	
	if theta < 0 {
		set theta to 360 + theta.
	}
	
	if theta > 360 {
		set theta to theta - 360.
	}
	
	clearscreen.
//	print "Ship Theta is " + round(theta_ship,2).
//	print "Theta is      " + round(theta,2).
//	wait 3.
	return theta.
}

function ETA_to_theta {

	parameter theta_test.
	
	local T_orbit to ship:orbit:period.
	local theta_ship to ship:orbit:trueanomaly.
	local e to ship:orbit:eccentricity.
	local GM to ship:body:mu.
	local a to ship:orbit:semimajoraxis.
	clearscreen.
	
	local EA_ship to 2*ARCTAN((TAN(theta_ship/2))/sqrt((1+e)/(1-e))).
	local MA_ship to EA_ship*constant:pi/180 - e*SIN(EA_ship).
	local EA_test to 2*ARCTAN((TAN(theta_test/2))/sqrt((1+e)/(1-e))).
	local MA_test to EA_test*constant:pi/180 - e*SIN(EA_test).
	local n to sqrt(GM/(a)^3).
	local eta_to_testpoint to (MA_test - MA_ship)/n.
	if eta_to_testpoint < 0 {
		set eta_to_testpoint to T_orbit + eta_to_testpoint.
	}
	
//	print "ETA to " + round(theta_test,2) + " degrees True Anomaly is " + round(eta_to_testpoint,2) + " seconds".
//	wait 2.
	return eta_to_testpoint.
}
	

//print DesiredOrbit["LAN"].
clearscreen.
clearvecdraws().
for n in allnodes { remove n.}

if DesiredOrbit["LAN"] = LAN_ship AND DesiredOrbit["INC"] = INC_ship {

	print "No Change to Inclination or LAN".
	wait 1.
	
} else {
	
	print "Running Change_LAN_Inc".
	Change_LAN_Inc(DesiredOrbit).
	wait 1.
}

// Next part is to creat a Change_AoP_PerApo function that will change the Argument of Periapsis, the Periapsis, and the Apoapsis